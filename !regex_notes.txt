POSITIVE LOOKAHEAD:
		re(?=gex)		//Will match the  "re" in "regex"

NEGATIVE LOOKAHEAD:
		re(?!gex)		//Will match the  "re" in "reguay"

POSITIVE LOOKBEHIND:
		(?<=re)gex		//Will match the "gex" in "regex"

NEGATIVE LOOKBEHIND:
		(?<!re)gex		//Will match the "gex" in "tirannosaurus gex"

BACKREFERENCE:
		<(.*)>.*</\1>	//Will match a whole XML element like "<h1>asd</h1>".
						//Keep in mind that "<h1>asd</h1></h1>" will alse be matched

DOTALL MODIFIER:
		(?s)			//Using this modifier at the beginning of the expression will
						// allow the dot character (".") to select every character, 
						// including newline characters

NON-GREEDY DOT-STAR:
						//Usually the ".*" in "<h1>.*</h1>" would match from the first
						// <h1> to the last </h1> in this example "<h1>asd</h1></h1>".
		.*?				//Using an interrogation symbol it becomes non-greedy, so it will
						// just match "<h1>asd</h1>" in the last example.

CHARACTER CLASSES:
	Character classes are pretty basic, they let you select any character inside square brackets:
		[A-Za-z0-9]		//This character class will match any letter in upper/lowercase, any
						// one-digit number

	But did you know you can also use negated character classes to match ANYTHING except the
	characters in the class?
		[^0-9]			//This will match anything except a number.

		//This will match from the A to the first B inside that A. For example:
			// using the expression "A:.*B" will match both elements
			// using the expression "A:[^\}]*B" will match the first one
			
			A: [{ /*things inside json file*/ B:'value'}], A: [{ /*things inside json file*/ B:'value'}]

		//You can use this with the dotall modifier in order to mass-replace a JSON file.


TIPS:
	When you see your regex is getting too complex, you might want to consider solving the problem in
	more than one step. For instance, if you have to select all SQL statements in an XML file and find
	something in them, you might want to first look for all SQL query tags and then perform the search.
	Something like this:
	1)	<sql>(.*?)</sql>
	2)	FROM (.*) WHERE
	This will prevent the regex engine from finding matches within two different <sql> tags and will
	make writing your regex easier overall.


CONCRETE EXAMPLES:

	> Line not containing word: 

				^((?!word).)*$

	> Line containing one or more words in list:

				^.*(this|that|other|...).*$	

	> Select all keys and values inside a json file without quotes (for example, to put the quotes): 

				(?![\s\t])(?<=[:=\[\]{},\s])([^\[\]{}=:,]+)(?=[:=\[{}\],])

			Using group 1 for replacing you can put the quotes in JSON files like this one:

				{transformXmlNode=[{xpath=//Name/First/text(), newValue=NEW NAME}, {xpath=//Name/Last/text(), newValue=LAST NAME}]}

			Replace with:

				"$1" (quotes included)

			Will yield the following result:

				{"transformXmlNode"=[{"xpath"="//Name/First/text()", "newValue"="NEW NAME"}, {"xpath"="//Name/Last/text()", "newValue"="LAST NAME"}]}